#pragma once
#include <stdint.h>

// #define ABS(x) ((x) < 0 ? -(x) : (x))

/**
 * @brief Номера битов слова состояния процессора (ССП)
 */
enum PSW_BITS
{
    PSW_C = 0, /**< Флаг переноса, устанавливается, если был перенос из старшего разряда (15-го при словных операциях и 7-го при байтовых) */
    PSW_V,     /**< Флаг арифметического переполнения, при сложении вычисляется как исключающее ИЛИ переносов из старшего и предстаршего разрядов */
    PSW_Z,     /**< Флаг равенства результата нулю, устанавливается, если все биты результата ([15:0] при словных операциях и [7:0] при байтовых) */
    PSW_N,     /**< Флаг знака результата, равен старшему разряду (15-му для словных операций и 7-му для байтовых) */
    PSW_T,     /**< Флаг ловушки пошаговой отладки. Установленный бит T вызывает программное исключение по вектору 014 */
    PSW_I = 7, /**< Единичное значение бита I маскирует прерывания IRQ */
    PSW_PA0,   /**< Младший бит номера процессора в системе */
    PSW_PA1,   /**< Старший бит номера процессора в системе */
    PSW_PSW10, /**< Модифицирует обработку исключения зависания шины, если данный бит ненулевой, то исключение зависания
                * будет обрабатываться в пультовом режиме по вектору 160002 */
    PSW_PSW11  /**< Модифицирует обработку исключения зависания шины, если данный бит ненулевой, то исключение зависания
                * будет обрабатываться в пультовом режиме по вектору 160002, иначе обработка по вектору 0000048 без перехода в пультовой режим */
};

/**
 * @brief Получает слово состояния процессора (ССП)
 */
inline uint16_t get_PSW()
{
    char rv;
    asm volatile (
        "mfps\n"
        "mov r0, %0"
        : "=r" (rv)
    );

    return rv;
}

/**
 * @brief Устанавливает слово состояния процессора (ССП)
 */
inline void set_PSW(uint16_t psw)
{
    asm volatile (
        "mov %0, r0\n\t"
        "mtps\n"
        : : "r" (psw)
    );
}

/**
 * @brief Обменивает местами байты в слове
  */
inline uint16_t SWAB(uint16_t word)
{
    asm volatile (
        "swab %0\n\t"
        : "=r" (word) : : "cc"
    );

    return word;
}

/**
 * @brief Вызывает инструкцию HALT
  */
inline void HALT(void)
{
    asm volatile (
        "halt\n\t"
    );
}

/**
 * @brief Вызывает инструкцию TRAP с заданным номером
  */
inline void TRAP(const uint8_t trap_no)
{
    asm volatile (
        "trap %[trap_no]\n\t"
        :
        : [trap_no]"I"(trap_no)
    );
}

/**
 * @brief Возвращает абсолютное значение 16-битного целого
 *
 * @param x - 16-битное целок
 */
inline uint16_t abs16(const int16_t x)
{
    uint16_t rv;

    asm volatile (
        "tst %[x]\n\t"
        "bge .l_pos%=\n\t"
        "neg %[x]\n"
".l_pos%=:\n\t"
        "mov %[x], %[rv]\n\t"
        : [rv]"=r"(rv)
        : [x]"r"(x)
        : "cc"
    );

    return rv;
}

/**
 * @brief Приостанавливает выполнение программы на заддное в параметре время.
 *
 * @param value - время в миллисекундах
 */
void delay_ms(uint16_t time);

/**
 * @brief ГСЧ основанный на 16-битном Xorshift LFSR с максимальным периодом использующим триплет 7,9,13 от John Metcalf
 *
 * @return 16-битное псевдо-случайное число
 */
uint16_t rand();

/**
 * @brief конвертирует значение числа указанной ширины в указанной системе счисления в строку
 *
 * @param value    - численное значение, которое необходимо вывести
 * @param base     - основание системы счисления (2..36), например 2 - для двоичных, 8 - для восьмеричных и т.д.
 * @param width    - если не равно нулю, то число будет дополнено до указанной в этом параметре ширины указанным символом
 * @param pad_char - символ, которым будет дополнено число слева до цказанной в параметре width ширины
 * @param str      - указатель на буфер, куда будет записана строка со значением числа
 *
 * @return - количество символов в строке со значением числа
 */
// uint8_t int_to_str(uint16_t value, uint8_t base, uint8_t width, char pad_char, char *str);

/**
 * @brief Преобразует значение целого числа в строку в десятичной системе счисления
 */
void uint_to_str(uint16_t value, char **str);
